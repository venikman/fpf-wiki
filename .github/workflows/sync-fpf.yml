name: Sync FPF Commits

on:
  # Scheduled polling - runs daily at 6 AM UTC
  schedule:
    - cron: '0 6 * * *'

  # Manual trigger with optional parameters
  workflow_dispatch:
    inputs:
      force_sync:
        description: 'Force sync even if no new commits'
        required: false
        default: 'false'
        type: boolean
      commit_count:
        description: 'Number of recent commits to sync (0 = auto-detect new)'
        required: false
        default: '0'
        type: number

env:
  UPSTREAM_REPO: 'ailev/FPF'
  UPSTREAM_BRANCH: 'main'
  SYNC_STATE_FILE: '.sync-state/last-synced-sha'

# Prevent concurrent syncs which could cause conflicts
concurrency:
  group: sync-fpf
  cancel-in-progress: false

jobs:
  check-and-sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write

    outputs:
      has_new_commits: ${{ steps.check-commits.outputs.has_new_commits }}
      new_commits_count: ${{ steps.check-commits.outputs.new_commits_count }}

    steps:
      - name: Checkout this repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remote
        run: |
          git remote add upstream "https://github.com/${UPSTREAM_REPO}.git" || true

          # Retry fetch with exponential backoff
          for i in 1 2 3 4; do
            if git fetch upstream "${UPSTREAM_BRANCH}"; then
              echo "Fetch successful"
              break
            fi
            if [ $i -eq 4 ]; then
              echo "::error::Failed to fetch upstream after 4 attempts"
              exit 1
            fi
            DELAY=$((2 ** i))
            echo "Fetch failed, retrying in ${DELAY}s..."
            sleep $DELAY
          done
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}

      - name: Check for new commits
        id: check-commits
        run: |
          # Ensure sync state directory exists
          mkdir -p .sync-state

          # Get last synced SHA (or empty if first run)
          LAST_SYNCED_SHA=""
          if [ -f "${SYNC_STATE_FILE}" ]; then
            LAST_SYNCED_SHA=$(cat "${SYNC_STATE_FILE}")
            echo "Last synced SHA: $LAST_SYNCED_SHA"
          else
            echo "First sync - no previous state found"
          fi

          # Get latest upstream SHA
          UPSTREAM_SHA=$(git rev-parse "upstream/${UPSTREAM_BRANCH}")
          echo "Upstream SHA: $UPSTREAM_SHA"

          # Check if force sync or commit count specified
          if [ "${INPUT_COMMIT_COUNT}" != "0" ] && [ -n "${INPUT_COMMIT_COUNT}" ]; then
            # Manual: sync specified number of commits
            echo "Manual sync: fetching last ${INPUT_COMMIT_COUNT} commits"
            COMMITS_TO_SYNC=$(git log "upstream/${UPSTREAM_BRANCH}" --oneline -n "${INPUT_COMMIT_COUNT}" --reverse --format="%H")
            NEW_COMMITS_COUNT=${INPUT_COMMIT_COUNT}
          elif [ -z "$LAST_SYNCED_SHA" ]; then
            # First run: sync only the latest commit
            echo "First sync: starting with latest commit only"
            COMMITS_TO_SYNC=$(git rev-parse "upstream/${UPSTREAM_BRANCH}")
            NEW_COMMITS_COUNT=1
          elif [ "$LAST_SYNCED_SHA" == "$UPSTREAM_SHA" ] && [ "${INPUT_FORCE_SYNC}" != "true" ]; then
            # No new commits
            echo "No new commits to sync"
            echo "has_new_commits=false" >> "$GITHUB_OUTPUT"
            echo "new_commits_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          else
            # Get commits since last sync
            COMMITS_TO_SYNC=$(git log "${LAST_SYNCED_SHA}..upstream/${UPSTREAM_BRANCH}" --reverse --format="%H")
            NEW_COMMITS_COUNT=$(echo "$COMMITS_TO_SYNC" | grep -c . || echo 0)
            echo "Found $NEW_COMMITS_COUNT new commits since $LAST_SYNCED_SHA"
          fi

          if [ -z "$COMMITS_TO_SYNC" ] || [ "$NEW_COMMITS_COUNT" -eq 0 ]; then
            echo "has_new_commits=false" >> "$GITHUB_OUTPUT"
            echo "new_commits_count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "has_new_commits=true" >> "$GITHUB_OUTPUT"
          echo "new_commits_count=$NEW_COMMITS_COUNT" >> "$GITHUB_OUTPUT"

          # Save commits to file (safer than passing through outputs for untrusted data)
          echo "$COMMITS_TO_SYNC" > /tmp/commits-to-sync.txt

          # Build JSON array of commit info and save to file
          # Using jq for proper JSON escaping of untrusted commit messages
          echo "[]" > /tmp/commits-info.json
          for SHA in $COMMITS_TO_SYNC; do
            SUBJECT=$(git log -1 --format="%s" "$SHA")
            AUTHOR=$(git log -1 --format="%an" "$SHA")
            DATE=$(git log -1 --format="%ci" "$SHA")

            # Use jq to safely build JSON with proper escaping
            jq --arg sha "$SHA" \
               --arg subject "$SUBJECT" \
               --arg author "$AUTHOR" \
               --arg date "$DATE" \
               '. += [{"sha": $sha, "subject": $subject, "author": $author, "date": $date}]' \
               /tmp/commits-info.json > /tmp/commits-info.tmp.json
            mv /tmp/commits-info.tmp.json /tmp/commits-info.json
          done
        env:
          SYNC_STATE_FILE: ${{ env.SYNC_STATE_FILE }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          INPUT_FORCE_SYNC: ${{ inputs.force_sync }}
          INPUT_COMMIT_COUNT: ${{ inputs.commit_count }}

      - name: Cherry-pick commits
        if: steps.check-commits.outputs.has_new_commits == 'true'
        id: cherry-pick
        run: |
          # Read commits to sync from file
          if [ ! -f /tmp/commits-to-sync.txt ]; then
            echo "No commits file found"
            exit 1
          fi

          COMMITS_TO_SYNC=$(cat /tmp/commits-to-sync.txt)
          echo "Commits to cherry-pick:"
          echo "$COMMITS_TO_SYNC"

          SYNCED_SHAS=""

          for SHA in $COMMITS_TO_SYNC; do
            echo "Cherry-picking $SHA..."

            if git cherry-pick --allow-empty -x "$SHA"; then
              echo "Successfully cherry-picked $SHA"
              SYNCED_SHAS="${SYNCED_SHAS} ${SHA}"
            else
              echo "::warning::Conflict cherry-picking $SHA - resolving by keeping our version"

              # For modify/delete conflicts: keep files deleted if we deleted them
              # For other conflicts: accept our version (theirs changes are logged in commit message)
              CONFLICTED_FILES=$(git diff --name-only --diff-filter=U 2>/dev/null || true)

              CONFLICT_RESOLVED=false
              if [ -n "$CONFLICTED_FILES" ]; then
                for FILE in $CONFLICTED_FILES; do
                  # Check if file exists in our HEAD (before cherry-pick started)
                  # Use -F for fixed string matching (no regex interpretation)
                  if git ls-tree -r HEAD --name-only | grep -Fxq "$FILE"; then
                    # File exists in our repo - keep our version
                    git checkout --ours "$FILE" 2>/dev/null || true
                    git add "$FILE" 2>/dev/null || true
                  else
                    # File was deleted in our repo - remove it
                    git rm -f "$FILE" 2>/dev/null || true
                  fi
                done

                # Complete the cherry-pick with resolved conflicts
                if git -c core.editor=true cherry-pick --continue; then
                  CONFLICT_RESOLVED=true
                else
                  echo "::warning::Failed to continue cherry-pick, aborting"
                  git cherry-pick --abort 2>/dev/null || true
                fi
              else
                # No unmerged files, just abort
                git cherry-pick --abort 2>/dev/null || true
              fi

              # Clean up any leftover untracked files from failed cherry-picks
              git clean -fd 2>/dev/null || true

              # Only mark as synced if conflict was actually resolved
              if [ "$CONFLICT_RESOLVED" = true ]; then
                SYNCED_SHAS="${SYNCED_SHAS} ${SHA}"
              else
                echo "::warning::Skipped $SHA due to unresolved conflict"
              fi
            fi
          done

          # Update sync state with latest processed SHA
          if [ -n "$SYNCED_SHAS" ]; then
            LATEST_SHA=$(git rev-parse "upstream/${UPSTREAM_BRANCH}")
            mkdir -p "$(dirname "${SYNC_STATE_FILE}")"
            echo "$LATEST_SHA" > "${SYNC_STATE_FILE}"

            git add "${SYNC_STATE_FILE}"
            git commit -m "chore: update sync state to $LATEST_SHA" || true
          fi

          echo "synced=true" >> "$GITHUB_OUTPUT"
        env:
          SYNC_STATE_FILE: ${{ env.SYNC_STATE_FILE }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}

      - name: Generate sync report page
        if: steps.cherry-pick.outputs.synced == 'true'
        run: |
          # Read commits info (already JSON-escaped by jq in previous step)
          COMMITS_COUNT=$(jq length /tmp/commits-info.json)

          # Generate date-based filename
          SYNC_DATE=$(date -u +%Y-%m-%d)
          SYNC_TIME=$(date -u +%H%M%S)
          REPORT_FILE="docs/_reports/${SYNC_DATE}-sync-${SYNC_TIME}.md"

          # Get first commit subject for summary (sanitized via jq)
          FIRST_SUBJECT=$(jq -r '.[0].subject // "Sync update"' /tmp/commits-info.json | head -c 100)

          # Ensure reports directory exists
          mkdir -p docs/_reports

          # Generate the report markdown file using heredoc with variables
          # Note: All commit data is safely escaped through jq
          cat > "$REPORT_FILE" << REPORT_EOF
---
layout: report
title: "Sync Report - ${SYNC_DATE}"
date: $(date -u +%Y-%m-%dT%H:%M:%S+00:00)
commits_count: ${COMMITS_COUNT}
summary: "$(echo "$FIRST_SUBJECT" | sed 's/"/\\"/g')"
---

## Sync Summary

**Source:** [${UPSTREAM_REPO}](https://github.com/${UPSTREAM_REPO})
**Commits synced:** ${COMMITS_COUNT}
**Sync time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)

## Commits

| SHA | Message | Author |
|-----|---------|--------|
REPORT_EOF

          # Add each commit as a table row (using jq to safely extract and format)
          # jq handles all escaping of untrusted commit message content
          jq -r '.[] | "| `\(.sha[0:7])` | \(.subject | gsub("[|]"; "\\|") | gsub("[\n\r]"; " ")) | \(.author) |"' /tmp/commits-info.json >> "$REPORT_FILE"

          # Add footer
          cat >> "$REPORT_FILE" << FOOTER_EOF

---

*View the full changes on [GitHub](https://github.com/${UPSTREAM_REPO}/commits/${UPSTREAM_BRANCH})*
FOOTER_EOF

          echo "Generated report: $REPORT_FILE"

          # Stage the new report
          git add docs/_reports/
          git commit -m "docs: add sync report for ${SYNC_DATE}" || true
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}

      - name: Push changes
        if: steps.cherry-pick.outputs.synced == 'true'
        run: |
          # Retry push with exponential backoff
          for i in 1 2 3 4; do
            if git push origin main; then
              echo "Push successful"
              exit 0
            fi
            if [ $i -eq 4 ]; then
              echo "::error::Failed to push after 4 attempts"
              exit 1
            fi
            DELAY=$((2 ** i))
            echo "Push failed, retrying in ${DELAY}s..."
            sleep $DELAY
          done
